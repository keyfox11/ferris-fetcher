use axum::{
    extract::Path,
    routing::{get, post},
    Extension, Json, Router,
};
use std::process::Command;
use std::sync::Arc;
use tokio::sync::Mutex;
use tower_http::cors::{Any, CorsLayer};
use uuid::Uuid; // NEW: Needed for file saving

mod engine;
use engine::{DownloadStatus, DownloadTask};

type AppState = Arc<Mutex<Vec<DownloadTask>>>;

// NEW: specific file to save our history
const HISTORY_FILE: &str = "history.json";

#[tokio::main]
async fn main() {
    // 1. Load History on Startup
    let initial_data = load_history();
    let state: AppState = Arc::new(Mutex::new(initial_data));

    // 2. Start the Auto-Save Background Task
    let state_clone = state.clone();
    tokio::spawn(async move {
        loop {
            tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            save_history(&state_clone).await;
        }
    });

    let app = Router::new()
        .route("/api/downloads", get(list_downloads).post(add_download))
        .route("/api/downloads/:id/open", post(open_file_location))
        .layer(Extension(state))
        .layer(
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any)
                .allow_headers(Any),
        );

    println!("Ferris Fetcher listening on localhost:3000");
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

// NEW: Helper to load JSON from disk
fn load_history() -> Vec<DownloadTask> {
    if let Ok(data) = std::fs::read_to_string(HISTORY_FILE) {
        serde_json::from_str(&data).unwrap_or_else(|_| Vec::new())
    } else {
        Vec::new()
    }
}

// NEW: Helper to save JSON to disk
async fn save_history(state: &AppState) {
    let tasks = state.lock().await;
    // Pretty print make it easy for you to read the file manually if needed
    if let Ok(json) = serde_json::to_string_pretty(&*tasks) {
        let _ = std::fs::write(HISTORY_FILE, json);
    }
}

async fn list_downloads(Extension(state): Extension<AppState>) -> Json<Vec<DownloadTask>> {
    let tasks = state.lock().await;
    Json(tasks.clone())
}

#[derive(serde::Deserialize)]
struct CreateDownload {
    url: String,
}

async fn add_download(
    Extension(state): Extension<AppState>,
    Json(payload): Json<CreateDownload>,
) -> Json<DownloadTask> {
    let id = Uuid::new_v4().to_string();
    let new_task = DownloadTask {
        id: id.clone(),
        url: payload.url.clone(),
        filename: "Pending...".to_string(),
        total_size: None,
        downloaded_bytes: 0,
        status: DownloadStatus::Pending,
        save_path: String::new(),
    };

    {
        let mut tasks = state.lock().await;
        tasks.push(new_task.clone());
    }

    // Save immediately on add so we don't lose it if we crash 1 second later
    save_history(&state).await;

    let state_clone = state.clone();
    tokio::spawn(async move {
        let _ = engine::start_multistream_download(payload.url, id, state_clone).await;
    });

    Json(new_task)
}

async fn open_file_location(
    Path(id): Path<String>,
    Extension(state): Extension<AppState>,
) -> Json<String> {
    let tasks = state.lock().await;
    if let Some(task) = tasks.iter().find(|t| t.id == id) {
        if cfg!(target_os = "windows") {
            Command::new("explorer")
                .arg("/select,")
                .arg(&task.save_path)
                .spawn()
                .expect("Failed to open explorer");
        }
    }
    Json("Opened".to_string())
}
